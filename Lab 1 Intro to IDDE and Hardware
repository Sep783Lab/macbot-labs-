Laboratory 1
Embedded IDE; Installing IDE used for embedded development
Signal processing; Python installation for signal processing and graphing

 
 

o	The mobile robot contains an Nvidia Jetson, and this is a powerful ARM processor with an integrated GPU (used for ROS as well as AI experimentation)
o	Modules can be plugged straight into the USB port of a computer
o	Modules: (GPS/GNSS/GLONASS,RF Ranging Time-of-Flight, IMU and Magnetometer, Depth Camera, LiDAR, Ultrasonic)
You will have access to these modules for the first five labs to use them during lab time. You can keep the modules to do the lab assignment at home. Please keep them safe since you must return all modules to school at the end of the semester.

 

Contents
1.	Scope of the lab:	3
2.	Lab objective:	3
3.	Installing our IDE of choice "Visual Studio Code"	3
4.	Installing Python3 and pip	4
5.	Setting up visual studio code for Python	7
6.	Setting up visual studio code for MacIoT development	9
7.	Understanding the VS code and PlatformIO environment	10
8.	Creating the first PlatformIO project	12
9.	Install MacIot board’s USB driver	15
10.	Intro to MacIoT board	17
11.	Intro to programming on MacIoT board	19
12.	Review of programming in C++:	21
13.	Add library to project	23
Installing the MCP23017 Library	23
14.	Blinking an LED:	29
15.	Lab Assignment 1:	32

 
1.	Scope of the lab: 
-	Installing all the tools we need for future development 
-	Platform IO will be installed for our embedded systems development 
-	Python and its package manager will be installed for signal processing and conditioning 

2.	Lab objective:
We will download Visual Studio Code as our Integrated Development Environment (IDE). Once we have that setup, we will install the PlatformIO extension within Visual Studio Code to help streamline our workflow for embedded development. We will also install python 3 and its package manager "pip" for more advanced work. 
3.	Installing our IDE of choice "Visual Studio Code" 
You can skip this step (step 3)  if you are using computers in the lab since they already have VSC. For your personal computer to have VSC, the following steps:

Download Visual Studio Code  (https://code.visualstudio.com/download) for whichever operating system you are currently working on. Once downloaded, go ahead and install it. We will be working from a windows 10 machine for demonstration purposes, although there won't be too many differences with the software if you are using Linux or MAC OS. When the installation is finished, open up the software, and you should see a screen like the following: 
 
Fig. 1. Visual Studio Code IDE

4.	Installing Python3 and pip
The great thing about visual studio code is that we can use it for both embedded development, as well as python development. Follow the installation instructions in this link : click here (https://www.python.org/downloads/) also available on course webpage

1.	Run the installer and make sure "Add Python 3.x to PATH" is check marked. Then we want to click "Install now" NOT customize installation 
 
 
Fig. 2 Installing Python3

2.	Test installation by opening the "CMD" command prompt and then typing "py", and as you can see python interpreter shows up and is using the latest version. 
 
Fig. 3 Installing Python3
3.	Now we want to see whether PIP is installed correctly; PIP is a package manager, meaning whenever we want to use an external library for python projects, we can simply install this library using commands provided by pip. We will test this by installing a handy library called "numpy". In our python interpreter from our previous step, type "import numpy" because we have not yet installed "numpy" this should throw an error. Let's see:
 
Fig. 4 Installing Python3-PIP
Now we will open a new command prompt, leaving this on open and type "pip install numpy". This will install the "numpy" library and link it to our python interpreter. We will also run another command recommended by CMD to upgrade PIP to it's latest version. 

 
Fig. 5 Installing Python3-PIP
You can also upgrade your PIP as: "python -m pip install --upgrade pip"
 
Fig. 6 Installing Python3-PIP- Numpy update

NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more. Install "NumPy": "pip install numpy"
 
Fig. 7 Installing Python3-PIP- Numpy update
After this the "import numpy" command will not throw an error. If it does, you may require a restart of your system. It should look like this:

  
Fig. 8 Installing Python3-PIP- import Numpy
We have now installed Python and PIP, and we can now write code in VS code and run it through Python. An example of this will be shown shortly, and our next step is to set up our VS code environment for both embedded system development and Python. 
 
5.	Setting up visual studio code for Python 
1.	First, we will install an extension for VS code that will make our python coding experience much more manageable. Open the VS code from your computer and then go to extension and search for "python". Install the "Python" extension:

 
Fig. 9 Setting up visual studio code for Python
 
2.	Now we will test our environment with the following steps, first, we will create a new python file housing our simple python code. Then we will run this code through VS code. Create a new file from file -> new file and name it "hello.py", we will save it in our desktop for now, but later this can be saved anywhere on our computer. You may get a notification asking you to select your interpreter, if this happens, select the one we just installed in the previous steps. Our file will simply contain the code "print("hello world")" like the following: 
 
You can run the python program by clicking on "Run Python File in Terminal":
 
You can see the result of the run in the terminal window of the VS code.
 
We can now run this by opening up a terminal window, Terminal -> New terminal; this will give us a command prompt within the VS code environment. In this terminal, we can navigate where our file is saved; the "cd [name of folder]" command to navigate. 
 
Output terminal:
 
Fig. 10 Installing Python3-Hello World
You can also run the python script in the command prompt :
 
Fig. 11 Installing Python3-Hello World- Command prompt
6.	Setting up visual studio code for MacIoT development
1.	Install platformIO in VS code, platformIO is what we will use to create and upload code for our MacIoT board. Go to the Extensions tab and search for PlatformIO IDE. Go ahead and install the extension, and then restart Visual Studio Code.
 Fig. 12 6. Setting up visual studio code with platformIO

 
Fig. 13 PlatfromIO IDE
When our installation is complete, platformIO should show up as an Alien Icon on the left sidebar, and this is what the main page we will use looks like.

 
Fig. 14 PlatfromIO IDE
7.	Understanding the VS code and PlatformIO environment
Before we really dive deep, let's familiarize ourselves with our work environment. While Visual Studio Code may seem a bit daunting to some, it's actually not that bad! It's an extremely useful Integrated Development Environment (IDE), and all it takes is a little getting used to. Highlighted below are some of the main features of the User Interface (UI) that we'll be familiarizing ourselves with. As mentioned in the earlier sections, there is the Activity Bar. At the bottom is the Status Bar, where the PlatformIO icons are located. We'll go over them soon. Then the environment can be broken into two main views, where you have the Editor and the Panels:
•	The editor is where you edit your files and
•	 The panels will show various information such as output, debug, errors, etc. All very important. Finally, there is the Split Screen option for side-by-side development. 
For a more detailed overview, check out the User Interface Guide. If you're ever unsure what an icon is, hover over it and wait for a few seconds to its name.
 
Fig. 15 PlatfromIO IDE Screen
Activity Bar:
Explorer shows the current file directories or document tree. Search is self explanatory, and allows you to find and replace text within files. Source Control is for source control of git repositories. Don't worry too much about this, we'll get into it later. Run is for running debug files. We won't worry about this for now. Extensions is for managing and installing extensions.
PlatformIO:
Home brings up the PlatformIO home tab. Build compiles the project and links any dependencies. Upload flashes the code onto the device defined on whichever serial COM (Windows) or dev/tty/ (Mac) ports. Upload to Remote Device uploads code onto remote devices. We won't be using this. Clean will delete compiled object files, libraries and program binaries. Test runs local tests from the project. Run Task runs specific tasks Serial Monitor opens the serial monitor on the defined baud rate. New Terminal clears the terminal.
 
Fig. 16 PlatfromIO IDE Screen
8.	Creating the first PlatformIO project 
1.	With Visual Studio Code open, navigate to the PlatformIO (PIO) home screen. If you don't see the home screen, click on the PIO Icon in the Activity Bar. There, go ahead and click "Open". That should bring up the PIO Home screen.
 
2.	Under "Quick Access" within PIO Home, let's go ahead and create a New Project. The Project Wizard will appear. Call your project whatever you want. I'll be calling mine "First Project". As you have noticed, PIO supports hundreds of boards. For our purposes, we'll select the Espressif ESP32 Dev Module. This is because the MacIoT's system on a chip (SoC) microcontroller is the ESP32. Finally, the framework we'll be working with will be the Arduino framework. The first initialization needs an internet connection.

 
You may choose wherever as your file location. I'll be using the default location (User/Documents/PlatformIO/project/First Project). Hovering over the (?) will show the file path to the default location. Once you are finished creating your project, let's open it and inspect the contents.
 
 

Let's talk a bit about these files. A standard PIO project structure contains three main items:
●	lib - The directory which contains project specific (private) libraries.
●	src - The directory which contains your source code. Files such as (.c, .cpp, .ino, etc.)
●	platformio.ini - Project configuration file. This is an "INI" file which defines things such as the platform (espressif32), board (esp32dev), framework (arduino). When we were initially creating the project, we defined these parameters in the Project Wizard. This file will be modified as we define more things later on such as build options, library options, etc.
You are encouraged to take a look at all the files to familiarize yourself. The directory should look something like this when creating your first project:
1.	project_dir
2.	├── include
3.	│      └── README
4.	├── lib
5.	│      └── README
6.	├── platform.ini
7.	├── src
8.	│      └── main.cpp
9.	└── test
10.	      └── README











 
9.	 Install MacIot board’s USB driver
MacIoT board communicates to your computer using a USB port. You need to make sure to install a USB driver for this board.
1.	Connect your MacIoT board to your computer using USB-C cable
2.	Download the driver from the course webpage (CP21x_Universal_Windows_Driver) and exctract the folder.
3.	For Windows, check the “device manager.”.If the “CP2120N USB to UART Bridge Controller” is shown in the following picture, you need to install the driver for it.
 
Fig. 17 Device manager

4.	Now “Update driver” using “Browse my computer for drivers”.
5.	Select the path of the driver and install the driver
6.	Check the device manager again, you should be able to see the installed driver
 
Fig. 18 Device manager
 
10.	 Intro to MacIoT board
The MacIoT board structure is shown bellow:
 
Fig. 19 MacIoT Board

1.	Switches and Buttons: Used for simple inputs for fast prototyping of logic
2.	I2C chip: Used to allow for multiple I2C connections for simple and easy sensor expansion. 
3.	ESP32 MCU: This is the board's main brain, allowing us to connect over Bluetooth and WiFi. You can find all information about ESP 32 in “ESP32_Technical_reference_manual_en.” On the course webpage.
4.	9-AXIS IMU: A gyroscope and accelerometer combo used to figure out the orientation of the device as well as it's estimated motion in space. 
5.	Temp/Humidity: A simple IC that can read temperature and humidity levels in the surrounding environment. 
6.	Light sensor: A diode-based light sensor giving us a varied value indicating the light intensity of the environment. 
7.	The schematic of the MacIoT board is available in Lab 1 (please check the .pdf file for the schematic)
 
 
Fig. 20 MacIoT Board Schematic

11.	Intro to programming on MacIoT board
This section will familiarize us with some basic C++ programming fundamentals. To do so, we will connect the MacIoT board to our computer and then use the empty project we created in part. First, we will do a simple upload to make sure everything is working correctly, open up the project and then our main.cpp file, it should look like this, also plug in your MacIoT board and confirm that a blue light is present:

  
Fig. 21 MacIoT Board C++ programming using VSC

We will now hit the upload button to confirm that we have no issues while uploading code. This will take some time, but in the end you should see a screen like the following: 

 
Fig. 22 MacIoT Board C++ programming using VSC-Upload code

Congratulations, you have just uploaded your first-ever program. Now we will begin with some basic C++/Arduino programming principles, starting with a print statement, a handy tool for debugging and solving problems. Try the following and then hit upload again: 

#include <Arduino.h> //Always needed

void setup() {
  Serial.begin(9600); // open the serial port at 9600 bps:
}

void loop() {
  Serial.println("Hello, World!"); //Print statement
  delay(1000); //Delay 200 milliseconds
}
Fig. 23 MacIoT Board C++ programming using VSC-Serial comunication

After a successful "Upload", we need to reset the board, you can either unplug and plug the board again, or click the "RESET" button, then open up the serial monitor in VS CODE. The reset button is found at the following position: 
  
Fig. 24 MacIoT Board C++ programming using VSC-Software reset

As we can see we are now printing "Hello, World!" at 1 message per second. 

12.	Review of programming in C++:
1.	Variables - For a deeper understanding, read through lecture slide
●	A variable is a place hold data and reference back to 
●	Variables have different types, integers and strings are the most widely used. 
●	The example use case for variables: Maybe instead of printing "Hello World" we wanted to print by referencing a variable. Use the following code, upload it and see how it compares with the previous example: 

#include <Arduino.h> //Always needed

String hello = "Hello, World"; 

void setup() {
  Serial.begin(9600); // open the serial port at 9600 bps:
}

void loop() {
  Serial.println(hello); //Print statement
  delay(1000); //Delay 200 milliseconds
}
Fig. 25 MacIoT Board C++ programming using VSC-String variable

2.	Functions
●	Functions are a way for us to reuse code; if we have a particular block of code that is constantly being repeated, it is best to put this in a function. Functions in programming languages are fairly similar to functions in math, F(X), however, they do not always need to return a value. 
 
#include <Arduino.h> //Always needed
String hello = "Hello, World"; 

void setup() {
  Serial.begin(9600); // open the serial port at 9600 bps:
}

void loop() {
  delay(1000); //Delay 1000 milliseconds
  printer(hello);
}

//Defining a separate function 
void printer(String message){
  Serial.println(message); //Print statement
}

Fig. 26 MacIoT Board C++ programming using VSC-define a function
Once again we notice that this will perform the same task as the previous code. Please read more about functions:
 here (https://www.arduino.cc/en/Reference/FunctionDeclaration)
3.	Using external libraries 
●	Libraries can be installed in various methods, a library is simply a piece of code that we either create or download, which we can reference and use in our own projects. There are hundreds and thousands of libraries available online, and with platformIO they are straightforward to install. 
●	As indicated on the Arduino.cc website: "The Arduino environment can be extended through the use of libraries, just like most programming platforms. Libraries provide extra functionality for use in sketches, e.g. working with hardware or manipulating data. To use a library in a sketch, select it from Sketch > Import Library. A number of libraries come installed with the IDE, but you can also download or create your own."
●	Follow this guide to download the "MCP23017" library, in the end our directory will now look like the following and as you can see we now have 2 new files, these files contain an external library we will use for using GPIO pins.  

13.	Add library to project
Libraries provide a clean way of extending the functionalities of our code. We can have all sorts of libraries for different functions, and we just simply call the function in our main code. For the libraries that we'll use, they will have at least two files, header ".h" files and the source code ".c/cpp" files. Header files contain definitions of the functions defined in the source files. That's why in our main.cpp, we'll be including just the header file. We'll need to install a library that allows us to communicate with the IO expander that's on the I2C bus. The IO expander has all the buttons, switches, and LEDs.
Installing the MCP23017 Library
The MCP23017/MCP23S17 (MCP23X17) device family provides 16-bit, general-purpose parallel I/O expansion for I2C bus or SPI applications, it is 16-Bit I/O Expander with Serial Interface. The MCP23X17 consists of multiple 8-bit configuration (see the datasheet MCP23017). The 16-bit I/O port functionally consists of two 8-bit ports (PORTA and PORTB).registers for input, output and polarity selection, see the datasheet.
        
Fig. 27 I/O expansion: MCP23017/MCP23S17
The MCP23017 is integrated to the MacIoT board as shown. Switches and buttons are connected to digital IO port B (GPB) and LED are connected to digital IO port A. Using an I2C scanner (available in Lab1 material), we were able to determine the address of the IO expander, which is 0x20. You can also check the datasheet of MCP23017 and the connection to the MACIoT board.
  
Fig. 28 I/O expansion: MCP23017/MCP23S17 registers

 we can communicate with the IO expander. Now since we're planning on using the library, we need to know what functions the library has.

 
Fig. 29 I/O expansion: MCP23017/MCP23S17 registers
There are many ways to install a library. For now, we'll go with the simplest method which is just moving the library to our project's "lib" directory. Downloading the library as a ".zip", go ahead and unzip the file. Move the library folder to your project's "lib" folder.

 
Fig. 30 I/O expansion: MCP23017/MCP23S17 library

After copy the library folder, go back to Platform IO interface, you can see the library for you project has been updated,
 
Fig. 31 I/O expansion: MCP23017/MCP23S17 library
You can also see the library properties and references to this library. To use functions in a library you need to include the header file, the same name as library, to your project. In your main.cpp source file, include the header file with #include <MCP23017.h>.

#include <Arduino.h>
  #include <MCP23017.h> // IO serial expander library

void setup() {
  // put your setup code here, to run once:
}

void loop() {
  // put your main code here, to run repeatedly:
}
Fig. 32 I/O expansion: MCP23017/MCP23S17- include library

Let's test to see if the code compiles correctly. When we "Build" our project again, notice how the library is now being compiled. That's good! There should be no errors in the compilation. To see various functions developed under this library, you can open the header file MCP23017.h or MCP23017.cpp,

 
Fig. 33 I/O expansion: MCP23017/MCP23S17 header file
Functions such as:
•	MCP23017::MCP23017
MCP23017::MCP23017(uint8_t address, TwoWire& bus) {
    _deviceAddr = address;
    _bus = &bus;
}

•	MCP23017::init:
void MCP23017::init()
{
    //BANK =    0 : sequential register addresses
    //MIRROR =  0 : use configureInterrupt 
    //SEQOP =   1 : sequential operation disabled, address pointer does not increment
    //DISSLW =  0 : slew rate enabled
    //HAEN =    0 : hardware address pin is always enabled on 23017
    //ODR =     0 : open drain output
    //INTPOL =  0 : interrupt active low
    writeRegister(MCP23017Register::IOCON, 0b00100000);

    //enable all pull up resistors (will be effective for input pins only)
    writeRegister(MCP23017Register::GPPU_A, 0xFF, 0xFF);
}

•	MCP23017::portMode: 
void portMode(MCP23017Port port, uint8_t directions, uint8_t pullups = 0xFF, uint8_t inverted = 0x00);
    /**
     * Controls a single pin direction. 
     * Pin 0-7 for port A, 8-15 for port B.
     * 
     * 1 = Pin is configured as an input.
     * 0 = Pin is configured as an output.

•	MCP23017::pinMode
void pinMode(uint8_t pin, uint8_t mode, bool inverted = false);

    /**
     * Writes a single pin state.
     * Pin 0-7 for port A, 8-15 for port B.
     * 
     * 1 = Logic-high
     * 0 = Logic-low

•	MCP23017::digitalWrite

void digitalWrite(uint8_t pin, uint8_t state);
    /**
     * Reads a single pin state.
     * Pin 0-7 for port A, 8-15 for port B.
     * 
     * 1 = Logic-high
     * 0 = Logic-low

•	MCP23017::digitalRead
uint8_t digitalRead(uint8_t pin);

    /**
     * Writes pins state to a whole port.
     * 
     * 1 = Logic-high
     * 0 = Logic-low

•	… (explore other functions of library)


14.	Blinking an LED:
Now we're ready to do the microcontroller's equivalent of "Hello World!": blinking an LED. Because this is the first program, we'll provide most of the source code. However, in the future it'll be as self-directed as possible. So, let's get started.

Currently in your main.cpp file, it should be the default Arduino starting template plus the #include <MCP23017.h> line we added during the compiling section. Before we begin coding, we should familiarize ourselves with the MCP23017 microchip, the 16-bit IO (Input / Output) expander. This is because the LEDs, switches, and buttons are all connected to the IO expander. And so, if we want to turn on an LED, we would need to learn how to interface with the IO expander. All LEDs are connected to portA of the MCP23017. So we need to define port direction for port A and write digital value to this port for blinking of LEDs. The values of PortA and PortB are transferred using I2C protocol, MCP23017 communicates with ESP32 via I2C. The I2C bus on the device has an I2C Master that is connected to two bidirectional lines, Serial Data Line (SDA) and Serial Clock Line (SCL). These two lines are connected to a pair of pins on the attached I2C slave device
  
To transfer data using I2C signal we need to use "wire.h" library. This library has several functions:
•	Wire.begin(address): Initiate the Wire library and join the I2C bus as a master or slave. This should normally be called only once.
•	Wire.requestFrom():Used by the master to request bytes from a slave device.
•	Wire.beginTransmission(address): Begin a transmission to the I2C slave device with the given address.
•	Wire.endTransmission(): Ends a transmission to a slave device that was begun by beginTransmission() and transmits the bytes that were queued by write().
•	Wire.write(): Writes data from a slave device in response to a request from a master, or queues bytes for transmission from a master to slave device
•	Wire.setClock():This function modifies the clock frequency for I2C communication. I2C slave devices have no minimum working clock frequency, however 100KHz is usually the baseline.
  This should also let us know that we need to use the Arduino Wire library and add #include <Wire.h> in our main source file.
#include <Arduino.h>
#include <MCP23017.h> // IO serial expander library
#include <Wire.h>     // I2C comunication


Let us use a #define directive to define our address. It essentially let's us define constant (non-changing) macros in our source code. So now, we should have something like this:
#include <Arduino.h>
#include <MCP23017.h> // IO serial expander library
#include <Wire.h>     // I2C comunication

// Defining the I2C Address of the MCP
#define MCP23017_ADDR 0x20

// Define an instance of the MCP23017 class
MCP23017 mcp = MCP23017(MCP23017_ADDR);
Some of you might be wondering how we're able to pass our hexadecimal address 0x20 as an unsigned integer of 8 bits (or 1 byte), designated as uint8_t. If you convert 0x20 into a decimal, you will get 32, which falls within the range of uint8_t (0 - 255).

Now in our void setup(), we'll need to join the I2C, because currently, we're not. Wire.begin(address) initiates the Wire library and joins the I2C bus as the master if we do not include any address. we must  also run the function mcp.init() in our setup, as this should be done once. On the IO expander, there are Port A and Port B GPIOs (General Purpose Input Output) pins. The MacIoT board has it set up so that the LEDs are on Port A, and the switches and buttons are on Port B. With that in mind, we need to set Port A as output (because we are writing to the GPIOs to turn LEDs on or off) and Port B as input (because we need are reading the GPIOs to see if the mechanical elements are changed).
void setup() {
  // put your setup code here, to run once:
  
  // Join I2C bus - more on this in later chapter 8)
  Wire.begin();
  // Initialize MCP
  mcp.init();

So we define the port direction ofMCP23017Port::A as 0, which configures it as an output. The port direction of MCP23017Port::B is a binary 0b11111111 (integer value 255). This configures the port to be an input. Finally the GPIO pins for Port A and B are resetted.
void setup() {
  // put your setup code here, to run once:
  
  // Join I2C bus - more on this in later chapter 8)
  Wire.begin();
  // Initialize MCP
  mcp.init();

  // Port A as Output (LEDS) || Port B as Input (Switches & Buttons)
  mcp.portMode(MCP23017Port::A, 0);                   // 0 = Pin is configured as an output (LEDs).
  mcp.portMode(MCP23017Port::B, 0b11111111);          // 1 = Pin is configured as an input (switches).

}

Now all that's left is to blink an LED of our choice. We will use the MCP digitalWrite function to choose the GPIO pin of our choice on Port A (LEDs). I'll simply be using the first one.
void loop() {
  // put your main code here, to run repeatedly:
  mcp.digitalWrite(0, 1);
  delay(250);
  mcp.digitalWrite(0, 0);
  delay(250);
}
Finally throw some delays in between and you got yourself a blinking LED! Not bad! We can also check the status of switches/buttons:
void loop() {
  int sw0;   // define variables for status of switch 0 
  // put your main code here, to run repeatedly:
  mcp.digitalWrite(0, 1);
  delay(250);
  mcp.digitalWrite(0, 0);
  delay(250);
  sw0=mcp.digitalRead(8);   // read the value of switch 0
  if (sw0==1){
     mcp.digitalWrite(1, 1);}
  else {
    mcp.digitalWrite(1, 0);}
}



 
15.	Lab Assignment 1:
Part 1:
-	Develop a program that turns on LEDs on the trainer board (GPA4-GPA7) when pressing the push button (GPB4-GPB7). For example, when you press GPB4 it will turn on GPA4.

Part 2:
-	Add the library of sensor module Si7020, temperature and humidity sensor,
-	Determine the I2C address of this sensor module
-	Develop the code to show the temperature when you press GPB4 in the terminal
-	Determine the accuracy of the measured temperature
-	Develop the code to show the relative humidity when you press GPB5 in the terminal
-	Determine the accuracy of the measured relative humidity
 
Part 3:
-	Add library of sensor module APDS-9306-065, light sensor
-	Determine the I2C address of this sensor module
-	Develop the code to show the light lux when you press GPB6 in the terminal
-	Test your measurement at the various light condition and discuss your result based on the functionality of light sensor


Submission (Check the dropbox due for Lab assignment 1)
-	Submit a report that explains each part of your code's functionality and answer the questions. Please add pictures to demonstrate the functionality of your code.
-	Submit a videos to demonstrate your work ( use camera/cell phone)
-	Only submit the .cpp file with your report ( no need to submit the libraies).

